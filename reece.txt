[] 1. Create a Firebase Account.
 [] Log in to the official Firebase console using your Google account credentials.
 [] Verify your account by following the email verification process and secure your login credentials.
 [] Document the account details in a secure location for later reference when configuring the project.

[] 2. Create a New Firebase Project.
 [] In the Firebase console, click on “Add project” and name the project “AI Video Editor for Educational Content.”
 [] Configure the project settings to match the intended region and usage patterns, ensuring that auto‑scaling features are enabled.
 [] Record the Firebase Project ID and initial settings for later use during integration with the codebase.

[] 3. Configure Firebase Authentication Settings.
 [] Within the Firebase project console, enable Firebase Authentication and set up sign‑in methods (e.g., email/password, Google Sign‑In).
 [] Configure role‑based access controls so that teachers have full create/update/delete permissions while students have read‑only access.
 [] Document the authentication configuration and note any custom claims or user attributes required by the PRD.

[] 4. Set Up Firebase Firestore Database.
 [] In the Firebase console, enable Firestore and select the appropriate regional settings to optimize latency and scalability.
 [] Define an initial schema including collections for Users, Videos, Transcripts, Annotations, and (optionally) Analytics as described in the PRD.
 [] Record and export the initial schema configuration as a JSON file for future reference and debugging.

[] 5. Configure Firebase Storage.
 [] Enable Firebase Storage in the Firebase console and define a hierarchical storage structure (e.g., /courses/{courseId}/lectures/{lectureId}/video.mp4).
 [] Set up security rules that allow authenticated teachers to upload and manage video files while limiting student access to read‑only operations.
 [] Test the storage configuration by uploading a small test file via the Firebase console and verifying its accessibility.

[] 6. Enable Firebase Analytics and Crashlytics.
 [] In the Firebase console, activate Firebase Analytics and Crashlytics to monitor real‑time app performance and error reporting.
 [] Configure basic settings such as event logging and crash alert thresholds according to project needs.
 [] Verify that sample events and crashes are being recorded by performing a manual test in the Firebase console.

[] 7. Create API Keys for Google Cloud Speech-to-Text.
 [] Log in to the Google Cloud Console and create a new project or use an existing one dedicated to speech services.
 [] Enable the Speech-to-Text API and generate a secure API key, ensuring that proper usage quotas and billing alerts are configured.
 [] Store the API key securely and document its usage guidelines to ensure proper integration into the application.

[] 8. Create an Account and API Access for Cloud-Based GPT/NLP Service.
 [] Register for the selected cloud-based GPT/NLP service (such as OpenAI or another provider) and configure the necessary API credentials.
 [] Review the API documentation to understand the rate limits, endpoint details, and authentication requirements.
 [] Securely store the API credentials and record any configuration details that will be needed for integration with the SmartEdit command processing.

[] 9. Configure Third‑Party Image APIs.
 [] Identify and register with external image sources such as Wikimedia Commons and set up API access if required by the project.
 [] Review the licensing and resolution requirements specified in the PRD and ensure that the API access complies with these conditions.
 [] Document the API endpoints, keys, and usage limits to support later integration for fetching high‑quality images.

[] 10. Establish a Git Repository for the Project.
 [] Create a new repository on your chosen Git hosting service and initialize it with a proper README and .gitignore file.
 [] Ensure that the repository structure reflects the planned folder hierarchy for frontend, backend, assets, and documentation.
 [] Secure the repository and record any branching or commit guidelines for future reference.

[] 11. Configure a Continuous Integration (CI) Environment.
 [] Choose a CI platform (such as GitHub Actions, CircleCI, or Bitrise) and link it to the Git repository for automated builds and tests.
 [] Set up CI configuration files that run unit tests, integration tests, and linting on every commit or pull request.
 [] Verify the CI environment by triggering a sample build and recording any issues for later troubleshooting.

[] 12. Document the Overall Project Architecture.
 [] Create an initial high‑level diagram of the project architecture, showing the interaction between the mobile frontend, Firebase backend, transcription services, and SmartEdit command processing.
 [] Ensure that the diagram includes all major components such as user authentication, data storage, video processing pipelines, and external API integrations.
 [] Save this diagram as part of the project documentation and reference it in future update logs.

[] 13. Define Security and Permissions Guidelines.
 [] Establish clear security policies that include HTTPS communications, encryption at rest and in transit, and Firebase Security Rules.
 [] Configure role‑based access in Firebase so that teachers can modify content while students have limited privileges.
 [] Document these guidelines in a secure location to ensure they are referenced during development and future audits.

[] 14. Configure Environment Variables and Secret Management.
 [] Create a secure method for storing environment variables such as API keys, Firebase configuration, and other sensitive data.
 [] Use tools such as .env files or secret managers and ensure that these files are excluded from version control.
 [] Document the environment variable names and expected values to assist with local and production deployments.

[] 15. Define the Initial Data Schema for Firestore Collections.
 [] Outline the data models for each Firestore collection (Users, Videos, Transcripts, Annotations) in a detailed schema document.
 [] Ensure that each field is defined with its data type, validation rules, and indexing requirements as specified in the PRD.
 [] Store this schema document in the project’s documentation repository for reference during code integration.

[] 16. Create a Detailed Deployment Plan Document.
 [] Draft a comprehensive deployment plan that outlines the steps for building, testing, and releasing the mobile application.
 [] Include details on environment configurations, CI/CD pipelines, and rollback strategies.
 [] Securely store this document and ensure it is updated whenever major changes occur.

[] 17. Set Up a Project Management Tool for Issue Tracking.
 [] Choose an issue tracking system (e.g., Jira, GitHub Issues) and configure it to track bugs, tasks, and feature enhancements.
 [] Create initial tasks that correspond to major milestones such as environment setup, frontend development, backend integration, and testing.
 [] Document the process for updating and closing issues to ensure smooth progress monitoring.

[] 18. Establish Naming Conventions and Code Style Guidelines.
 [] Develop a comprehensive style guide for the project that details naming conventions, file organization, and coding standards.
 [] Ensure that the style guide covers both frontend (Swift, SwiftUI/ UIKit) and backend (Firebase rules, JavaScript for Cloud Functions if used).
 [] Record these guidelines in the project repository so that all code is uniform and maintainable.

[] 19. Create a Backup Plan for Firebase Data and Storage.
 [] Configure automated backups for Firestore and Firebase Storage using Firebase’s built‑in tools or a third‑party solution.
 [] Verify that backups are scheduled and that restoration processes are documented in detail.
 [] Document the backup and restore procedures and store them in the project’s secure documentation.

[] 20. Create a Test Environment in Firebase.
 [] Set up a separate Firebase project or environment for testing purposes to avoid interfering with production data.
 [] Configure the same authentication, Firestore, and Storage rules in the test environment as in production.
 [] Document the test environment details and ensure that automated tests point to this environment during CI builds.

[] 21. Set Up Logging and Monitoring Tools.
 [] Ensure that Firebase Analytics, Crashlytics, and any additional logging tools are configured to capture performance and error data.
 [] Define the metrics to be monitored, such as upload progress, processing times, and command execution success rates.
 [] Document these metrics and establish alert thresholds for proactive monitoring.

[] 22. Establish Version Control and Branching Strategy Guidelines.
 [] Define a branching strategy (e.g., main, development, feature branches) that will be used consistently throughout the project lifecycle.
 [] Document commit message guidelines and merge policies to ensure that every change is traceable and reversible.
 [] Store these guidelines in the project repository for future reference by the developer.

[] 23. Create an Initial Project Roadmap Document.
 [] Outline the major milestones for the project, including environment setup, core feature development, testing, and deployment phases.
 [] Ensure that the roadmap is detailed enough to guide the development process from start to finish.
 [] Securely store the roadmap document and update it periodically as features are completed.

[] 24. Set Up a Local Development Environment.
 [] Ensure that the necessary tools (Xcode, command‑line tools, Git, etc.) are installed and configured on the development machine.
 [] Verify that all tools are up to date and that their paths and configurations are correct.
 [] Document the installation and configuration steps in a local README file for reference during troubleshooting.

[] 25. Define Integration Points with External APIs.
 [] Identify and document the endpoints and data exchange formats for external APIs such as Google Cloud Speech‑to‑Text, GPT/NLP, and image sources.
 [] Ensure that the integration points are mapped to specific functions in the project and that error handling is defined.
 [] Securely store this integration document and include sample API responses for testing purposes.

[] 26. Create a Detailed Testing Plan Document.
 [] Outline the testing strategy for unit tests, integration tests, and end‑to‑end tests covering all core functionalities.
 [] Define the testing framework, coverage targets, and procedures for regression testing.
 [] Document this plan and store it in the project repository to guide automated and manual testing.

[] 27. Configure a Local Emulator for Firebase Services.
 [] Install and configure the Firebase Emulator Suite to simulate Firestore, Authentication, and Storage locally.
 [] Validate that the emulator replicates production behavior to support thorough testing without affecting live data.
 [] Document the emulator setup and ensure that CI builds reference the emulator when appropriate.

[] 28. Establish a Rollback and Recovery Strategy.
 [] Develop a detailed strategy for rolling back deployments or recovering from critical errors in the production environment.
 [] Ensure that procedures for restoring backups, reverting code, and re‑configuring Firebase settings are fully documented.
 [] Securely store this strategy document and verify that it is accessible in an emergency.

[] 29. Create a Detailed API Documentation Outline.
 [] Draft an outline that details every API endpoint that the app will consume, including request/response formats, authentication methods, and error codes.
 [] Ensure that the documentation is granular enough to support autonomous integration and troubleshooting.
 [] Save the outline as part of the project’s central documentation repository.

[] 30. Define Data Validation Rules for User Input.
 [] Specify validation rules for every user input field (e.g., video file format and size, metadata fields) according to the PRD.
 [] Ensure that these rules are reflected in both the frontend and backend logic and that error messages are defined.
 [] Document the validation rules in a dedicated file and cross‑reference them with the data schema document.

[] 31. Create a Project Glossary of Terms and Acronyms.
 [] Compile a glossary that defines key terms such as “SmartEdit,” “AVAsset,” “Firestore Document,” and other project‑specific language.
 [] Ensure that each term is explained in detail and linked to its corresponding feature or module in the PRD.
 [] Store the glossary in the documentation repository so that all future references are consistent and unambiguous.

[] 32. Set Up a Dedicated Documentation Folder in the Repository.
 [] Create a folder structure in the Git repository specifically for all project documentation, including diagrams, API specs, and design guides.
 [] Ensure that each document is clearly named and versioned for ease of reference and future updates.
 [] Document the folder structure in the project’s main README and enforce its usage for all documentation updates.

[] 33. Prepare a Detailed Meridian Diagram Documentation (mermaid.md).
 [] Draft the mermaid.md document that outlines guidelines for creating and maintaining all Mermaid diagrams used in the project.
 [] Include sections for diagram types, syntax rules, styling guidelines, and integration instructions as specified.
 [] Save this document in the documentation folder and reference it in all related diagrams.

[] 34. Define a Logging and Monitoring Configuration Document.
 [] Create a document that details the configuration settings for Firebase Analytics, Crashlytics, and any additional logging tools.
 [] Ensure that it includes details on event names, log levels, and integration points with the application code.
 [] Store this document securely and update it whenever logging configurations are modified.

[] 35. Set Up a Dedicated Issue-Tracking Board in the Project Repository.
 [] Use your chosen issue-tracking tool to create a board that organizes tasks by feature, bug, and enhancement, aligned with the project roadmap.
 [] Ensure that each issue is labeled with priority, module, and detailed reproduction steps where applicable.
 [] Document the issue‑tracking process in the project management guidelines for future autonomous tracking.

[] 36. Define the Command-Line Tooling and Scripts to Be Used.
 [] Identify and document all command-line tools, build scripts, and automation commands (such as SPM commands, Xcode build commands, etc.) that will be used during development.
 [] Ensure that each tool is described with its purpose, usage syntax, and configuration details.
 [] Store this documentation in the repository’s docs folder for quick reference during the coding phase.

[] 37. Create a Detailed Testing Environment Setup Document.
 [] Write a document that details how to set up the local, staging, and production testing environments, including emulator configurations and test data seeding.
 [] Ensure that every step for environment preparation is clearly outlined and version controlled.
 [] Save and version this document in the project repository to guide future automated testing setups.

[] 38. Establish a Strict Branch Merging and Code Review Policy.
 [] Define a policy for merging branches, including required tests, peer reviews, and CI checks before any merge can occur.
 [] Ensure that the policy is documented and automated in the CI/CD pipeline where possible to avoid manual errors.
 [] Record this policy in the version control guidelines and enforce it through automated scripts if applicable.

[] 39. Create a Detailed Data Backup and Disaster Recovery Plan.
 [] Draft a plan that specifies how Firestore and Firebase Storage backups will be taken, stored, and restored in case of data loss or system failure.
 [] Ensure that the plan is tested by simulating a recovery scenario and that all steps are fully documented.
 [] Store the plan securely and reference it in the maintenance documentation for quick recovery in emergencies.

[] 40. Finalize and Archive All Human‑Side Configuration Documents.
 [] Review all documents created in the Human Instructions section, ensuring that they are complete, versioned, and stored in the designated documentation folder.
 [] Verify that every configuration (Firebase, API keys, environment variables, backup plans) is recorded and accessible for troubleshooting and future reference.
 [] Archive these documents securely and notify the AI instructions (via internal references) so that the code can refer to these settings during integration.

AI Instructions (Steps 41–260)
